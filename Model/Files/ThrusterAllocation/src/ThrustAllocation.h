/*
 * ThrustAllocation.cpp
 *
 *  Copyright: 	NTNU, Trondheim, Norway
 *  Licensed under GPL-3.0
 *  Created:  	May 7, 2013	Torstein Aarseth BÃ¸ <torstein.bo@sintef.no>
 *  Revised:	<date>	<author> <description>
 *		   		<date>	<author> <description>
 *
 */

#ifndef THRUSTALLOCATION_H_
#define THRUSTALLOCATION_H_

#include <vector>
#include <acado_toolkit.hpp>
#include <iostream>
#include "singularity_cost_wrapper.h"

using namespace std;
using namespace ACADO;

#define ushort unsigned short
#define uint unsigned int
#define NTHRUSTERS 6

#define ASSERT(test,msg) if(!(test)){ cerr << msg; throw 20;}

/**
 * \brief A class for thrust allocation
 *
 * This is a implementation of thrust allocation. From a desired thrust are thrust demands for thrusters calculated with azimuth angles and maximum power limit.
 * ACADO is used for solving the NLP. Singularity avoidance is implemented but two C++-files must be generated by "SingularityAvoidance.m" from matlab (singularity_cost.cpp and singularity_cost_gradient.cpp).
 *
 */
class ThrustAllocation {
public:
	/// Constructor
	ThrustAllocation(const uint nThruster, ///< Number of thrusters on vessel
			const uint nSwitchboards,       ///< Number of switchboards
			const double TauMax[],      ///< Maximum thrust of each thruster [m]
			const double Kt2p[], ///< Thrust to power gain [W/N^1.5] power is assumed to be P = Kt2p |T|^1.5
			const uint thruster2switchboard[], ///< connectivity vector, index is index of thruster, value is index of switchboard
			const double xPosition[], ///< x-Position of thruster[m]
			const double yPosition[], ///< y-Position of thruster [m]
			const double fRampTime[], ///< Minimum time to go from 0 thrust to maximum thrust [s]
			const double turnTime[], ///< Minimum time to turn thruster 360 degrees [s]
			const double fMin[], ///< Minimum thrust demand (maximum is set to 1)
			const bool rotable[], ///< True if thruster is rotable
			const double reverseThrustPowerGain[], ///< Extra power used when thrust is reversed
			const double sampleTime, ///< Sample time of thruster allocation
			const double singularityCostGain, ///< Singularity cost gain
			const double singularityCostSmoother, ///< Singularity cost smoother (1/(smoother+|x|))
            const double dAngleCost, ///< Cost of changig angle
            const double dfCost ///< Cost of changing absolute thrust
			);

	virtual ~ThrustAllocation();

	/// Calculates thrust demand given a desired thrust
	bool thrust(const double tau_d[], ///< Desired thrust in surge, sway and. yaw [N,N,Nm]
			const double powerAvailableBus[], ///< Power reserved for thrust at each bus [W]
			const double powerAvailableThruster[], ///< Power reserved for each thruster [W]
			const uint switchboard2bus[], ///< Mapping from switchboard index to bus index, index is switchboard index, value is bus index
			const uint nbus, ///< Number of busses
			const bool thrusterOn[], ///< Vector of thrusters on, index is thruster index, value=1 if thruster is on 0 if thurster is off
			const double fOld[], ///< Current thrust command
			const double alphaOld[], ///< Current azimuth angles [rad]
			double f[], ///< [out] Thruster demand [-1..1]
			double alpha[], ///< [out]  Azimuth angle of thruster [rad]
			double powerAllocatedThruster[] = 0 ///[out] Maximum power used by each thruster [W]
			);

	/// Initialize optimization (for a warmer start)
	void initialize(const double f[], const double alpha[]);

	/// Get number of thrusters
	inline uint getNThrusters() const {return _nthrusters;}

	/// Get number of switchboard
	inline uint getNSwitchboard() const {return _nswitchboards;}

	enum PrintLevel {
		PL_NONE, PL_LOW, PL_MEDIUM, PL_HIGH
	};

	/// Set print level of solver
	inline void setPrintLevel(ThrustAllocation::PrintLevel printlevel) {
		_printLevel = printlevel;
	}

	void dump() const;


private:
	const uint _nthrusters; ///< Number of thrusters
	const uint _nswitchboards; ///< Number of switchboards
	uint _nbus; ///< Number of busses
	bool* _thrustersOn; ///< Thrusters connected and with power
	vector<double> _xPosition; ///< SCALED x-position of thrusters
	vector<double> _yPosition; ///< SCALED y-position of thrusters
	vector<double> _dfMax; ///< Maximum change of thrust demand [%/iteration]
	vector<double> _dAlphaMax; ///< Maximum change of azimuth angle [rad/iteration]
	const vector<double> _fMin;	///< Minimum thrust demand (maximum is set to 1)
	vector<double> _Ku2p;	///< SCALED Thruster input to power P = Ku2p*u^1.5
	vector<double> _thrustMax;  ///< SCALED maximum thrust of thrusters
	vector<char> _rotable; ///< True if thruster is rotable
	const vector<uint> _thruster2switchboard;
	vector<double> _reverseThrustPowerGain; ///< Extra power used when thrust is reversed
	vector<uint> _switchboard2bus; ///< Index is switchboard index, value is bus index
	const double _sampleTime; ///< Time between each run of thruster allocation [s]
	DVector _pLast; ///< Previous solution
	const double _singularityCostGain; ///< Singularity cost gain
	const double _singularityCostSmoother; ///< Singularity cost smoother (1/(smoother+|x|))
	SingularityCostWrapper _singularityCostWrapper;
    const double _dAngleCost; ///< Cost of changig angle
    const double _dfCost;
	ThrustAllocation::PrintLevel _printLevel;

	/// Return bus ID of thruster
	uint inline thruster2bus(const uint &thrusterNr ///< Thruster ID
			) const;

	/// Check if the solution u fulfills the power and slew rate constraint constraints
	inline bool isFeasible(const double u[], ///< Thrust demand solution
			const double powerAvailableBus[], ///< SCALED Available power for each bus
			const double powerAvailableThruster[], ///< SCALED Available power for each thruster
			const double uOld[] ///< Current u
			) const;

	/// Scale power from Watt to normalized
	inline static void scalePower(const uint size, ///< Size of vector
			double t[] /**< Vector to be scaled */);

	/// Scale power from normalized to Watt
	inline static void unScalePower(const unsigned int n, ///< Size of vector
			double power[] /**< Vector to be scaled back to Watt */);

	/// Scale thrust command for Newton to normalized
	inline static void scaleThrust(const uint size, ///< Size of vector
			double t[] /**< Vector to be scaled */);

	/// Scale thrust demand in Surge [N], Sway[N], and Yaw[Nm] to normalized
	inline static void scaleTau(double t[]);

	/// Scale length from meter to normalized
	inline static void scaleLength(const uint size, ///< Size of vector
			double t[] /**< Vector to be scaled */);

	/// Scale thrust to power gain from W/N^1.5 to normalized
	inline static void scaleKt2p(const uint size, ///< Size of vector
			double t[] /**< Vector to be scaled */);

	/// Calculates allowed power usage based on thruster allocation
	void powerAllocation(const double f[], const double powerAvailableBus[],
			double powerThrusters[]) const;

	/// Solve the Thrust Allocation problem
	returnValue solve(const double tau_d[], ///< SCALED thrust demand
			const double powerAvailableBus[], ///< SCALED available power on bus
			const double powerAvailableThruster[], ///< SCALED available power on thruster
			CFunction &singularityCostFun, ///< Cost function for singularity avoidance cost
			const double fOld[], ///< Current thrust command
			const double alphaOld[], ///< Current azimuth angles [rad]
			const signed char directionList[], ///< List of direction of thruster, true if positive thrust
			const bool fixThrusterAngles, ///< Fix direction of thruster to make problem easier to solve
			double f[], ///< [out] Thruster demand [-1..1]
			double alpha[], ///< [out]  Azimuth angle of thruster [rad]
			double &cost, ///< [out] Objective cost of solution
			DVector &pResult ///< [out] Result vector
			) const;

	/** Finds optimal TA solution for different direction list and returns the best solution
	 *
	 * Iteratively check if solution is more optimal by switching direction of one thruster (but not the iCurrent first thrusters).
	 * Starts by checking if thrust demand of thruster i>=iCurrent  is set to zero, if so this function is run recursively to check if there exist a better solution,
	 *  but freezes the direction of the (i+1) first thrusters.
	 */
	void findBestDirection(const double tau_d[], ///< Desired thrust
			const double powerAvailableBus[], ///< Power available of bus
			const double powerAvailableThruster[], ///< Power available of thrusters
			CFunction &singularityCostFun, ///< Singularity cost function
			const double fOld[], ///< Current thrust command
			const double alphaOld[], ///< Current azimuth angle
			const double fCurrent[], ///< Currently best thrust magnitude command solution
			const double alphaCurrent[], ///< Currently best thrust angle command solution
			const signed char directionListCurrent[],///< Currently best direction list solution
			const double costCurrent,///< Currently lowest cost solution
			const uint iCurrent, ///< Currently freezed direction list item (set to 0, this is used in recursion)
			const bool fixThrusterAngles, ///< Freezes thruster angles
			double fBest[], ///<[out] Best thrust magnitude command solution
			double alphaBest[], ///<[out] thrust angle command solution
			double &costBest,  ///<[out] Lowest cost
			DVector &pResult ///<[out] Parameter list for SQP solver
			) const;

	/** Set which thrusters which are active
	 *
	 * @param[in] thrustersOn Boolean vector of connection status of thrusters (1 if on and connected).
	 * @return True if something has change, else false
	 */
	inline bool setActiveThrusters(vector<bool> thrustersOn);

	/// Set Ku2p from scaled Kt2p and K matrix
	void setKu2pK(const double NSKt2p[], ///< Not scaled thrust to power gain [W/N^1.5]
			const double NSK[] //// Not scaled maximum thrust of thrusters [N]
			);

	/// Set electrical configuration
	void setPlantConfiguration(const uint switchboard2bus[], ///< Vector of mapping from switchboard to bus
			const uint nbus ///< Number of busses
			);

	/// Check if bus is alive by checking if powerAvailableBus has small values, in that case the thrusters are disconnected
	void setThrustersOn(const double powerAvailableBus[], ///< Scaled power available of bus
			const bool thrustersOn[] ///< Connected thrusters
			);

	/// Check if any thruster is connected
	inline bool isAnyThrusterConnected() const;

	/// Find initial direction list
	vector<signed char> findDirection0(const double* f0) const;

	/// Print direction list
	void printDirectionList(const signed char directionList[]) const;

	/** Fix direction of thrust.
	 *
	 * Fix direction of thrust such that abs(alpha-alpha0) is minimized
	 *  (i.e. if thrust is reverse alpha is rotated 180 deg)
	 *
	 * @param f desired thrust of thruster
	 * @param alpha desired azimuth angle of thruster
	 * @param[in] alpha0 current azimuth angle of thruster
	 */
	void fixDirection(double f[], double alpha[], const double alpha0[]) const;

	/** Convert thrust from polar coordinates to cartesian coordinates
	 * @param[in] f Array of force magnitude
	 * @param[in] alpha Array of force direction
	 * @param[out] ux Force in x-direction
	 * @param[out] uy Force in y-direction
	 */
	inline void convertFtoU(const double f[], const double alpha[], double ux[],
			double uy[]) const;

	/// Returns number of optimization variables
	inline unsigned int nOptVariables() const;
	/// Returns force to power gain \f$ p = Ku2p |f|^{1.5}\f$
	inline double getKu2p(int thrusterI, signed char direction) const;

	static const double TAU_BASE;
	static const double POWER_BASE;
	static const double LENGTH_BASE;
	static const unsigned short DOF = 3;
	static const double FMAX;
};

class WrongAcadoException : exception { // "You are using a version of acado which always gives a cost of zero. Check github.com/tibnor/acado");

};

#endif /* THRUSTALLOCATION_H_ */
