/*
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is a wrapper S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_wrapper_XXXXX_Changes_BEGIN 
  *            Your Changes go here
  *        %%%-SFUNWIZ_wrapper_XXXXXX_Changes_END
  *
  *   For better compatibility with the Simulink Coder, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Simulink Coder User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *   Created: Sun Oct  5 23:33:58 2014
  */


/*
 * Include Files
 *
 */
#if defined(MATLAB_MEX_FILE)
#include "tmwtypes.h"
#include "simstruc_types.h"
#else
#include "rtwtypes.h"
#endif

/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */
#include <math.h>
/* %%%-SFUNWIZ_wrapper_includes_Changes_END --- EDIT HERE TO _BEGIN */
#define u_width 3
#define y_width 1
/*
 * Create external references here.  
 *
 */
/* %%%-SFUNWIZ_wrapper_externs_Changes_BEGIN --- EDIT HERE TO _END */
/* %%%-SFUNWIZ_wrapper_externs_Changes_END --- EDIT HERE TO _BEGIN */



/* %%%-SFUNWIZ_wrapper_Update_Changes_END --- EDIT HERE TO _BEGIN */
void ThdynCV2ZoneBG_Update_wrapper(const real_T *p,
                          const real_T *Tu,
                          const real_T *Fu,
                          const real_T *Vu,
                          const real_T *Tb,
                          const real_T *Fb,
                          const real_T *Vb,
                          const real_T *xC,
                          const real_T *combState,
                          real_T *Tu_prev,
                          real_T *Ru_prev,
                          real_T *uu_prev,
                          real_T *Cvu_prev,
                          real_T *Tb_prev,
                          real_T *Rb_prev,
                          real_T *ub_prev,
                          real_T *Cvb_prev,
                          real_T *mb0,
                          real_T *ResetMix,        
                          const real_T  *fs,  const int_T  p_width0,
                          const real_T *alpha, const int_T p_widht3)
{
    real_T F_fs;
    real_T R1, h1, s1, u1, RF, RP, RT, uF, uP, uT, sF, sP, sT, Cp, Cv1, K;
    real_T R2, h2, s2, u2, Cv2;
    real_T muTemp, mbTemp;

    GetThdynCombGasZachV1(p[0],Tu[0],Fu[0],fs[0],&R1,&h1,&s1,&u1,
        &RF,&RP,&RT,&uF,&uP,&uT,&sF,&sP,&sT,&Cp,&Cv1,&K);            
    GetThdynCombGasZachV1(p[0],Tb[0],Fb[0],fs[0],&R2,&h2,&s2,&u2,
        &RF,&RP,&RT,&uF,&uP,&uT,&sF,&sP,&sT,&Cp,&Cv2,&K);      
    Tu_prev[0] = Tu[0];
    Ru_prev[0] = R1;
    uu_prev[0] = u1;
    Cvu_prev[0] = Cv1;
    Tb_prev[0] = Tb[0];
    Rb_prev[0] = R2;
    ub_prev[0] = u2;
    Cvb_prev[0] = Cv2;
    
          
    if(combState[0] == 2 && ResetMix[0] == 0)
    {
        ResetMix[0] = 1;
    }
    if(combState[0] == 5 && ResetMix[0] == 1)
    {
        ResetMix[0] = 0;

        mb0[0] = xC[4] - alpha[0]*(xC[0] + xC[4]);
    }
    
}


/*
  *  Derivatives function
  *
  */
void ThdynCV2ZoneBG_Derivatives_wrapper(const real_T *dmHmb,
                          const real_T *dV,
                          const real_T *dmfb,
                          const real_T *FComb,
                          const real_T *dQCyl,
                          const real_T *omega,
                          const real_T *phi,
                          real_T *dx,
                          real_T *xC, 
                          const real_T  *fs,  const int_T  p_width0,
                          const real_T  *DPhiMix,  const int_T  p_width1,
                          const real_T  *phiMix0,  const int_T  p_width2,
                          const real_T  *alpha,  const int_T  p_width3,
                          const real_T  *hn,  const int_T  p_width4,
                          const real_T  *nStroke, const int_T p_width5,
                          const real_T *Tu_prev,
                          const real_T *Ru_prev,
                          const real_T *uu_prev,
                          const real_T *Cvu_prev,
                          const real_T *Tb_prev,
                          const real_T *Rb_prev,
                          const real_T *ub_prev,
                          const real_T *Cvb_prev,
                          const real_T *mb0,
                          const int *resetMix)
{
/* %%%-SFUNWIZ_wrapper_Derivatives_Changes_BEGIN --- EDIT HERE TO _END */
const double pi = 3.14159265359;    
double p, T1, F1, V1, T2, F2, V2;
double Ffs;
double phiCyc, q;
double dmMix, dmbMix;
double R1,h1,s1,uu1,RF1,RP1,RT1,uF1,uP1,uT1,sF1,sP1,sT1,Cp1,Cv1,K1;
double R2,h2,s2,uu2,RF2,RP2,RT2,uF2,uP2,uT2,sF2,sP2,sT2,Cp2,Cv2,K2;
double mu, mb, mub, mbb;
double Uu, Ub;
double dmu, dmb, dmub, dmbb, dFu, dFb;
double dHu, dHb, dQu, dQb;
double a1, a2;
double u1, u2, u3, u4;
double a11, a12, a13, a14, a21, a22, a23, a24, a31, a32, a33, a34, a41, a42, a43, a44;
double aa1, aa2, aa3, aa4;
double detA;
double Tuu, Tub; // Partial derivative of T w.r.t. u;
double puu, pub; // Partial derivative of p w.r.t. u;
double Fuu, Fub; // Partial derivative of F w.r.t. u;
double detJu, detJb; // determinant of Jacobian of (p,T,F) -> (R,u,s)

phiCyc = phi[0]*180.0/pi;
phiCyc = ((int)(floor(phiCyc)) % ((int)(nStroke[0]*180))) + phiCyc - floor(phiCyc);

mu = xC[0];    Uu = xC[1];
mub = xC[2];   V1 = xC[3];

mb = xC[4];    Ub = xC[5];
mbb = xC[6];   V2 = xC[7];

GetPTF(mb, mbb, Ub, V2, *Tb_prev, *Rb_prev, *ub_prev, *Cvb_prev, *fs, &p, &T2, &F2);
GetPTF(mu, mub, Uu, V1, *Tu_prev, *Ru_prev, *uu_prev, *Cvu_prev, *fs, &p, &T1, &F1);

// Calculate the the mix rate
q = (phiCyc - phiMix0[0]) / DPhiMix[0];
if (q < 0)
{
    q = 0;
}
else
{
    if (q > 1)
    {
        q = 1;
    }
}
dmMix = mb0[0]*6*q*(1-q)*omega[0]/(DPhiMix[0]*pi/180);;
dmbMix = dmMix*(F2*fs[0]/(1+F2*fs[0]));
// Calculate the fuel equivalent ratio and its derivative
Ffs = FComb[0]*fs[0];

// Calculate the mass flow rate
dmu = dmHmb[0] - (1+Ffs)/Ffs*dmfb[0] + dmMix;
dmub = dmHmb[2] - dmfb[0] + dmbMix;
dmb = (1+Ffs)/Ffs*dmfb[0] - dmMix;
dmbb = dmfb[0] - dmbMix;

// Calculate the thermal dynamic properties of the zones
GetThdynCombGasZachV1(p,T1,F1,fs[0],&R1,&h1,&s1,&uu1,&RF1,&RP1,&RT1,&uF1,&uP1,&uT1,
        &sF1,&sP1,&sT1,&Cp1,&Cv1,&K1);
GetThdynCombGasZachV1(p,T2,F2,fs[0],&R2,&h2,&s2,&uu2,&RF2,&RP2,&RT2,&uF2,&uP2,&uT2,
        &sF2,&sP2,&sT2,&Cp2,&Cv2,&K2);

// Calculate the enthalpy flow rate
dHu = dmHmb[1] - (1/Ffs*h1 + hn[0])*dmfb[0] + dmMix*h2;
dHb = (1/Ffs*h1 + hn[0])*dmfb[0] - dmMix*h2;

// Calculate the cylinder heat transfer
dQu = dQCyl[0]*T1*mu / (T1*mu + T2*mb);
dQb = dQCyl[0] - dQu;

detJu = RP1*(uT1*sF1-uF1*sT1)-RT1*(uP1*sF1-uF1*sP1)+RF1*(uP1*sT1-uT1*sP1);
detJb = RP2*(uT2*sF2-uF2*sT2)-RT2*(uP2*sF2-uF2*sP2)+RF2*(uP2*sT2-uT2*sP2);
Tuu = (RP1*sF1 - RF1*sP1) / detJu;
Tub = (RP2*sF2 - RF2*sP2) / detJb;
puu = (RF1*sT1 - RT1*sF1) / detJu;
pub = (RF2*sT2 - RT2*sF2) / detJb;
Fuu = (RT1*sP1 - RP1*sT1) / detJu;
Fub = (RT2*sP2 - RP2*sT2) / detJu;

a1 = -V2*((RT1*T1 + R1)*Tuu + T1*(RP1*puu+RF1*Fuu));
a2 = V1*((RT2*T2 + R2)*Tub + T2*(RP2*pub+RF2*Fub));

aa1 = V1*V2*p;		    aa2 = V2+a2*aa1*p;	aa3 = V1-a1*aa1*p;		

a11 = -(V1+aa2)/aa1;    a12 = p*aa2/aa1;    a13 = -a2*p;            a14 = p;
a21 = a1;               a22 = -aa2/aa1;     a23 = a2;               a24 = -1.0;
a31 = a1*p;             a32 = p*aa3/aa1;    a33 = -(V2+aa3)/aa1;    a34 = -p;
a41 = -a1;              a42 = -aa3/aa1;     a43 = -a2;              a44 = 1;

detA = -(aa2 + aa3)/aa1;

u1 = -dQu + dHu; 
u2 = dV[0];
u3 = -dQb + dHb;
u4 = V2*dmu*(R1*T1 - ((RT1*T1 + R1)*Tuu+T1*(RP1*puu+RF1*Fuu))*uu1) - 
        V1*dmb*(R2*T2 - ((RT2*T2 + R2)*Tub+T2*(RP2*pub+RF2*Fub))*uu2);

dx[0] = dmu;
dx[1] = (a11*u1 + a12*u2 + a13*u3 + a14*u4)/detA;
dx[2] = dmub;
dx[3] = (a21*u1 + a22*u2 + a23*u3 + a24*u4)/detA;
dx[4] = dmb;
dx[5] = (a31*u1 + a32*u2 + a33*u3 + a34*u4)/detA;
dx[6] = dmbb;
dx[7] = (a41*u1 + a42*u2 + a43*u3 + a44*u4)/detA;
/* %%%-SFUNWIZ_wrapper_Derivatives_Changes_END --- EDIT HERE TO _BEGIN */
}